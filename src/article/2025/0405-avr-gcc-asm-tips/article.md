# [メモ] avr-gcc アセンブラ備忘録

AVR 向けのアセンブラに関する雑多なメモ。随時追加する。

## 参考資料

### 公式

- [AVR Assembler](https://ww1.microchip.com/downloads/en/DeviceDoc/40001917A.pdf)
- [AVR Instruction Set Manual](https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-InstructionSet-Manual-DS40002198.pdf)

### コミュニティ

- [avr-gcc - GCC Wiki](https://gcc.gnu.org/wiki/avr-gcc): ABI の説明がある
- [AVR Syntax - Using as](https://sourceware.org/binutils/docs-2.18/as/AVR-Syntax.html#AVR-Syntax)

----

## 一般的な用語

AVR は関係無い

### prologue (プロローグ)

呼び出された関数 (callee) が最初に行う処理。関数内の処理が呼び出し元 (caller) に影響しないよう、これから値を破壊 (clobber) する見込みのレジスタの待避したり、ローカル変数領域の確保など。

### epilogue (エピローグ)

呼び出された関数 (callee) が復帰する直前に行う処理。スタックフレームの解放、破壊したレジスタの復元など。

### clobber (クロバー, クラバー)

関数呼び出しやアセンブラの文脈では、レジスタの値を「破壊」すること。trash とか smash とかと同じ？「clobbered registers」と言った場合、関数呼び出しやインラインアセンブラによって値が破壊される可能性のあるレジスタであり、すなわち呼び出し側で事前に待避が必要であることを意味する。

----

## AVR で固定用途のレジスタ

### `r0`

一時変数用のスクラッチレジスタ。アセンブラソースでは `__temp_reg__` で参照される。

乗算命令 (`mul` など) の計算結果の格納にも使われる。

### `r1`

ゼロレジスタ。アセンブラソースでは `__zero_reg__` で参照される。

ハードウェア的には他の汎用レジスタと同様に機能するが、基本的には常に 0x00 を格納しておいて、定数ゼロとして使用することになっている。

乗算命令の計算結果の格納にも使われるので、乗算の後はゼロクリアする必要がある。

### `T` フラグ

ステータスレジスタ (`SREG`) 内にある。`r0` と同様に一時変数として使用される。

### `Y` (`r29:r28`)

スタックフレーム内のローカル変数への間接アクセス用に使用される。

### `r8`～`r25`

固定用途ではないが、引数をレジスタで渡す際はこの範囲内で使用される。

----

## 関数呼び出し規約

C 言語で適当に関数を作って `avr-gcc -S` で生成したアセンブラを眺めながらドキュメントを読むと理解しやすい。

### 呼び出し側 (caller) が待避しなければならないレジスタ (clobbered registers)

これらは callee によって破壊されるので、復帰後も caller で値を使用する場合は呼び出し前に待避しなければならない。

- `r0` (`__temp_reg__`): 一時変数用レジスタ
- `r18–r25`: 汎用レジスタ
- `X`(`r27:r26`), `Z`(`r31:r30`): ポインタ
- `T`フラグ: `r0` と同様、ビット操作時の一時変数として使用

### 呼び出される側 (callee) が待避しなければならないレジスタ (saved registers)

caller はこれらはのレジスタが復帰後も呼び出し前の値を維持していることを期待するので、callee で使用する場合はその前に待避し、復帰前に復元しなければならない。

- `r1` (`__zero_reg__`): 値の格納に使用した場合は復帰前までにゼロクリアすること。
- `r2-r17`: 汎用レジスタ
- `Y`(`r29:r28`): ポインタ

### スタックフレーム

スタックはアドレスの若番方向へ向かって積まれる。スタックの内容とスタックポインタ (`SP`) はアライメントされない。

|アドレス|サイズ \[Bytes\]|内容|説明|
|:--:|:--:|:--:|:--|
|↑大|≧ 0|引数|レジスタ渡しでは足りない場合に caller が積む|
||0 または 2～3|復帰先アドレス|caller が積む。末尾呼び出しの場合は 0 のこともある|
||≧ 0|待避されたレジスタ<br>(saved registers)|必要に応じて callee が積む|
|↓小|≧ 0|ローカル変数|必要に応じて callee が確保する|

clobbered registers は呼び出し元の責任で待避するので、呼び出し元のローカル変数領域に含まれる。

### プロローグの処理

1. saved registers のうち自身が使用 (破壊) するものをスタックに `push` して待避する。
2. `SP` の値を `Y` (`r29:r28`) レジスタにコピーし、ローカル変数領域のサイズ分を減算する。
3. `Y` レジスタの値を `SP` に書き戻す。
4. レジスタ渡しされた引数を必要に応じてローカル変数領域にコピーする。

`SP` を介した間接アクセスができないので、スタック内の引数やローカル変数へのアクセスは `Y` レジスタを介して行う。

### エピローグの処理

1. `Y` レジスタにローカル変数領域のサイズを加算して `SP` に書き戻す。
2. saved registers をスタックから `pop` して復元する。
3. 戻り値をレジスタまたはスタックに配置する。
4. 復帰する (`ret`)。

### 引数

可変長でない 16 バイトまでの引数は `r25` から若番方向へ向かって確保したレジスタに配置し、それに収まらない分はスタックに積む。

1. 全ての引数のサイズを偶数に切り上げる。
2. 切り上げ後の引数のサイズの合計で 16 バイトまでに収まる分はレジスタに配置する。

    - `r25` から始めて若番方向に向かって引数を配置する。
    - 奇数サイズのレジスタは若番側 (偶数番側) にアライメントする。
    - 16 バイトから 1 バイトでも溢れたらその引数はスタックに積まれる。1 つの引数がレジスタとスタックに泣き別れたりはしない。

3. 16 バイトから溢れた残りの引数は全てスタックに積む。

可変長引数 (varargs) の場合は全ての引数をスタックに積む。

### 戻り値

8 バイトまでの戻り値は `r25` から若番方向に向かって確保したレジスタに配置する。

- 構造体でない戻り値は引数と同様、サイズを偶数に切り上げる。

    - 例) `uint8_t` の引数は `r24` に配置する (`r25` はパディング)。
    - 例) `uint32_t` の引数は `r25:r22` に配置する (`r25` が MSB 側、`r22` が LSB 側)。

- 構造体は 2 のべき乗に切り上げる。

    - 例) 6 バイトの構造体は `r23:r18` に配置する (`r25:r24` はパディング)。

----

## 文法

### プロプロセッサ

ソースファイルの拡張子を大文字で `.S` にすることにより、C/C++ と同様のプリプロセッサが使用でき、`#define` などのお馴染みのマクロが使える。

> You can use the gnu C compiler driver to get other "CPP" style preprocessing by giving the input file a `.S` suffix.<br>
> [3.1 Preprocessing - Using as](https://sourceware.org/binutils/docs-2.18/as/Preprocessing.html#Preprocessing)