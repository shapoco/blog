# [メモ] avr-gcc アセンブラ / ABI 備忘録

avr-gcc 向けのアセンブラと ABI に関する雑多なメモ。随時追加する。

## 参考資料

### 公式

- [AVR Assembler](https://ww1.microchip.com/downloads/en/DeviceDoc/40001917A.pdf)
- [AVR Instruction Set Manual](https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-InstructionSet-Manual-DS40002198.pdf)

### コミュニティ

- [ELM - アセンブラ関数の書き方(avr-gcc)](http://elm-chan.org/docs/avrlib/asm_gcc.html)
- [avr-gcc - GCC Wiki](https://gcc.gnu.org/wiki/avr-gcc)  ABI の説明がある
- [AVR Syntax - Using as](https://sourceware.org/binutils/docs-2.18/as/AVR-Syntax.html#AVR-Syntax)

## 用語メモ

AVR は直接関係無い。

### prologue (プロローグ)

呼び出された関数 (callee) が最初に行う処理。関数内の処理が呼び出し元 (caller) に影響しないよう、これから値を破壊 (clobber) する見込みのレジスタの待避したり、ローカル変数領域の確保など。

### epilogue (エピローグ)

呼び出された関数 (callee) が復帰する直前に行う処理。スタックフレームの解放、破壊したレジスタの復元など。

### clobber (クロバー, クラバー)

関数呼び出しやアセンブラの文脈では、レジスタの値を「破壊」すること。trash とか smash とかと同じ？「clobbered registers」と言った場合、関数呼び出しやインラインアセンブラによって値が破壊される可能性のあるレジスタであり、すなわち呼び出し側で事前に待避が必要であることを意味する。

## ABI

C 言語で適当に関数を作って `avr-gcc -S` で生成されたアセンブラを眺めながらドキュメントを読むと理解しやすい。

### レジスタの用途

#### r0

一時変数用のスクラッチレジスタ。アセンブラソースでは `__temp_reg__` で参照される。

乗算命令 (`mul` など) の計算結果の格納にも使われる。

#### r1

ゼロレジスタ。アセンブラソースでは `__zero_reg__` で参照される。

ハードウェア的には他の汎用レジスタと同様に機能するが、基本的には常に 0x00 を格納しておいて、定数ゼロとして使用することになっている。

乗算命令の計算結果の格納にも使われるので、乗算の後はゼロクリアする必要がある。

手書きアセンブラで乗算命令を頻繁に使用する場合は `r1:r0` 以外をゼロレジスタとして使った方が命令数は少なくなる。

#### T フラグ

ステータスレジスタ (`SREG`) 内にある。`r0` と同様に一時変数として使用される。

#### Y (`r29:r28`)

スタックフレーム内のローカル変数への間接アクセス用に使用される。

#### r8～r25

関数の中では固定用途ではないが、引数をレジスタで渡す際はこの範囲内で使用される。

### 関数呼び出し

#### 呼び出し側 (caller) が待避しなければならないレジスタ (clobbered registers)

これらは callee によって破壊されるので、復帰後も caller で値を使用する場合は呼び出し前に待避しなければならない。

- `r0` (`__temp_reg__`): 一時変数用レジスタ
- `r18–r25`: 汎用レジスタ
- `X`(`r27:r26`), `Z`(`r31:r30`): ポインタ
- `T`フラグ: `r0` と同様、ビット操作時の一時変数として使用

#### 呼び出される側 (callee) が待避しなければならないレジスタ (saved registers)

caller はこれらはのレジスタが復帰後も呼び出し前の値を維持していることを期待するので、callee で使用する場合はその前に待避し、復帰前に復元しなければならない。

- `r1` (`__zero_reg__`): 値の格納に使用した場合は復帰前までにゼロクリアすること。
- `r2-r17`: 汎用レジスタ
- `Y`(`r29:r28`): ポインタ

### スタックフレーム

スタックはアドレスの若番方向へ向かって積まれる。スタックの内容とスタックポインタ (`SP`) はアライメントされない。

|アドレス|サイズ \[Bytes\]|内容|説明|
|:--:|:--:|:--:|:--|
|↑大|≧ 0|引数|レジスタ渡しでは足りない場合に caller が積む|
||0 または 2～3|復帰先アドレス|caller が積む。末尾呼び出しの場合は 0 のこともある|
||≧ 0|待避されたレジスタ<br>(saved registers)|必要に応じて callee が積む|
|↓小|≧ 0|ローカル変数|必要に応じて callee が確保する|

clobbered registers は呼び出し元の責任で待避するので、呼び出し元のローカル変数領域に含まれる。

### プロローグの処理

1. saved registers のうち自身が使用 (破壊) するものをスタックに `push` して待避する。
2. `SP` の値を `Y` レジスタにコピーし、ローカル変数領域のサイズ分を減算する。
3. `Y` レジスタの値を `SP` に書き戻す。
4. レジスタ渡しされた引数を必要に応じてローカル変数領域にコピーする。

`SP` を介した間接アクセスができないので、スタック内の引数やローカル変数へのアクセスは `Y` レジスタを介して行う。

### エピローグの処理

1. `Y` レジスタにローカル変数領域のサイズを加算して `SP` に書き戻す。
2. saved registers をスタックから `pop` して復元する。
3. 戻り値をレジスタまたはスタックに配置する。
4. 復帰する (`ret`)。

### 引数

可変長でない 16 バイトまでの引数は `r25` から若番方向へ向かって確保したレジスタに配置し、それに収まらない分はスタックに積む。

1. 全ての引数のサイズを偶数に切り上げる。
2. 切り上げ後の引数のサイズの合計で 16 バイトまでに収まる分はレジスタに配置する。

    - `r25` から始めて若番方向に向かって引数を配置する。
    - 奇数サイズのレジスタは若番側 (偶数番側) にアライメントする。
    - 16 バイトから 1 バイトでも溢れたらその引数はスタックに積まれる。1 つの引数がレジスタとスタックに泣き別れたりはしない。

3. 16 バイトから溢れた残りの引数は全てスタックに積む。

可変長引数 (varargs) の場合は全ての引数をスタックに積む。

### 戻り値

8 バイトまでの戻り値は `r25` から若番方向に向かって確保したレジスタに配置する。

- 構造体でない戻り値は引数と同様、サイズを偶数に切り上げる。

    - 例) `uint8_t` の値は `r24` に配置する (`r25` はパディング)。
    - 例) `uint32_t` の値は `r25:r22` に配置する (`r25` が MSB 側、`r22` が LSB 側)。

- 構造体は 2 のべき乗に切り上げる。

    - 例) 6 バイトの構造体は `r23:r18` に配置する (`r25:r24` はパディング)。

## 文法

### プリプロセッサ

ソースファイルの拡張子を大文字で `.S` にすることにより、C/C++ と同様のプリプロセッサが使用でき、`#define`、`#ifdef`、`#if` などのお馴染みのマクロが使える。

> You can use the gnu C compiler driver to get other "CPP" style preprocessing by giving the input file a `.S` suffix.<br>
> [3.1 Preprocessing - Using as](https://sourceware.org/binutils/docs-2.18/as/Preprocessing.html#Preprocessing)

`#include` も使えるので、C/C++ 側で使う定数を定義したファイルを共通化できる。

## つまづいたところ

### オペランドに指定可能なレジスタが制限されている命令

|カテゴリ|命令|指定可能な範囲|
|:--|:--|:--|
|Immediate 系|`andi`, `cpi`, `ldi`,<br>`ori`, `sbci`, `subi`|`r16`-`r31`|
|Ser/Clear Bit 系|`cbr`, `sbr`, `ser`|`r16`-`r31`|
|Load Direct<br>from Data Space|`lds`|AVRrc: `r16`-`r31`<br>その他: 制限なし|
|乗算|`muls` (`mul` は制限なし)|`r16`-`r31`|
|乗算|`mulsu`,<br>`fmul`, `fmuls`, `fmulsu`|`r16`-`r23`|

### ポインタレジスタと命令の使い分け

単に配列を舐めるのには `X`～`Z` のどれでも使えるが、配列を Read-Modify-Write したり構造体へアクセスするには displacement addressing ができる `Y`、`Z` の方が使いやすい。`Y` は通常はローカル変数へのアクセスに使われる。

|アドレッシング|X|Y, Z|
|:--|:--:|:--:|
|Indirect|`ld`/`st`|`ldd`/`std`|
|Post-increment|`ld`/`st`|`ld`/`st`|
|Pre-decrement|`ld`/`st`<br>(未検証)|`ld`/`st`<br>(未検証)|
|Displacement|不可|`ldd`/`std`|

#### post-increment したいときは `ldd` ではなく `ld` を使う？

`ldd rN, Z+` は期待した動作にならなかったが `ld rN, Z+` だと期待動作になった。理由は分からない。深追いもできてない。

### その他

- `addi rN, hoge` は無いが `subi rN, (-hoge)` で同じことができる。同様に `adci` も無いので `sbci` を使う。
